//
// > Notice: Floating Trees Inc. @ 2025
// > Create Time: 2025-07-28 20:22:33
//

#include "kd/shaders/common/bindless.kds"
#include "kd/shaders/common/camera.kds"
#include "kd/shaders/common/math.kds"
#include "kd/shaders/common/compute.kds"
#include "kd/shaders/common/lights.kds"

#pragma compute CSMain

static const int SHADOW_CASCADE_COUNT = 4;
static const int SHADOW_MAP_SIZE = 2048;

float PCFCascade(
    Texture2D<float> ShadowMap,
    SamplerComparisonState comparisonSampler,
    float4 WorldSpacePosition,
    float4x4 LightView,
    float4x4 LightProj,
    float bias,
    int kernelSize)
{
    // Transform world-space position into light space
    float4 lightSpacePosition = mul(LightView, WorldSpacePosition);
    float4 ndcPosition = mul(LightProj, lightSpacePosition);
    ndcPosition.xyz /= ndcPosition.w;

    // Compute shadow map UV coordinates
    float2 shadowUV = ndcPosition.xy * 0.5 + 0.5;
    shadowUV.y = 1.0 - shadowUV.y;

    // Check if outside the light frustum
    if (ndcPosition.z > 1.0)
        return 1.0;

    // Compute texel size for PCF kernel sampling
    uint shadowWidth, shadowHeight;
    ShadowMap.GetDimensions(shadowWidth, shadowHeight);
    float2 texelSize = 1.0 / float2(shadowWidth, shadowHeight);

    // Perform PCF with the comparison sampler
    float shadow = 0.0;
    int sampleCount = 0;

    for (int x = -kernelSize; x <= kernelSize; x++) {
        for (int y = -kernelSize; y <= kernelSize; y++) {
            // Offset UV coordinates for sampling
            float2 offsetUV = shadowUV + float2(x, y) * texelSize;

            // Use the comparison sampler to perform the depth test
            shadow += ShadowMap.SampleCmpLevelZero(comparisonSampler, offsetUV, ndcPosition.z - bias);
            sampleCount++;
        }
    }
    shadow /= sampleCount;

    return shadow;
}

struct Cascade
{
    uint SRVIndex;
    float Split;
    float2 Pad;

    column_major float4x4 View;
    column_major float4x4 Proj;
};

struct PushConstants
{
    uint CascadeArrayIndex;
    uint SamplerIndex;
    uint CameraIndex;
    uint DepthIndex;

    uint OutputIndex;
    uint SunIndex;
    uint NormalIndex;
    uint Pad;

    uint Width;
    uint Height;
    uint2 Pad1;
};
PUSH_CONSTANTS(PushConstants, Push);

float CalculateShadowCascade(float4 world, float3 N, float3 L, int layer)
{
    ConstantBuffer<Camera> camera = ResourceDescriptorHeap[Push.CameraIndex];
    StructuredBuffer<Cascade> cascades = ResourceDescriptorHeap[Push.CascadeArrayIndex];

    float distanceToCamera = length(camera.Position.xyz - world.xyz);
    Cascade cascade0 = cascades[layer];
    Cascade cascade1 = cascades[min(layer + 1, SHADOW_CASCADE_COUNT - 1)];

    SamplerComparisonState sampler = SamplerDescriptorHeap[Push.SamplerIndex];
    Texture2D<float> shadowMap0 = ResourceDescriptorHeap[cascade0.SRVIndex];
    Texture2D<float> shadowMap1 = ResourceDescriptorHeap[cascade1.SRVIndex];

    float texelSize0 = cascade0.Split / SHADOW_MAP_SIZE;
    float texelSize1 = cascade1.Split / SHADOW_MAP_SIZE;

    float slopeBias = 0.05;
    float minBias = 0.005;

    float bias0 = max(slopeBias * (1.0 - dot(N, L)), minBias) * texelSize0;
    float bias1 = max(slopeBias * (1.0 - dot(N, L)), minBias) * texelSize1;

    int kernelSize = 2;

    float shadow0 = PCFCascade(shadowMap0, sampler, world, cascade0.View, cascade0.Proj, bias0, kernelSize);
    float shadow1 = PCFCascade(shadowMap1, sampler, world, cascade1.View, cascade1.Proj, bias1, kernelSize);

    // Compute blend factor near cascade split
    float blendRange = 0.1; // 10% of split range
    float blendStart = cascade0.Split * (1.0 - blendRange);
    float blendFactor = saturate((distanceToCamera - blendStart) / (cascade0.Split - blendStart));

    return lerp(shadow0, shadow1, blendFactor);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 dtid: SV_DispatchThreadID)
{
    // Start
    if (dtid.x >= Push.Width || dtid.y >= Push.Height)
        return;

    // Load resources
    RWTexture2D<float> output = ResourceDescriptorHeap[Push.OutputIndex];
    Texture2D<float> depth = ResourceDescriptorHeap[Push.DepthIndex];
    Texture2D<float4> normal = ResourceDescriptorHeap[Push.NormalIndex];
    StructuredBuffer<DirectionalLight> sun = ResourceDescriptorHeap[Push.SunIndex];
    StructuredBuffer<Cascade> cascades = ResourceDescriptorHeap[Push.CascadeArrayIndex];
    ConstantBuffer<Camera> camera = ResourceDescriptorHeap[Push.CameraIndex];

    // Load data
    float viewDepth = depth.Load(dtid);
    float2 uv = TexelToUV(dtid.xy, float2(Push.Width, Push.Height));
    float3 cameraPosition = camera.Position.xyz;
    float4 worldPosition = GetWorldFromDepth(uv, viewDepth, camera.InvViewProj);
    float3 N = normalize(normal.Load(dtid).rgb);
    float3 L = -sun[0].Direction;

    int layer = -1;
    for (int i = 0; i < SHADOW_CASCADE_COUNT; i++) {
        if (abs(LinearizeDepth(viewDepth, CAMERA_NEAR, CAMERA_FAR)) < cascades[i].Split) {
            layer = i;
            break;
        }
    }
    if (layer == -1) {
        layer = SHADOW_CASCADE_COUNT - 1;
    }

    // Algorithm
    output[dtid.xy] = 1.0f * CalculateShadowCascade(worldPosition, N, L, layer);
}
