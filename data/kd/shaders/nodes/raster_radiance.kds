//
// > Notice: Floating Trees Inc. @ 2025
// > Create Time: 2025-07-28 21:55:39
//

#include "kd/shaders/common/bindless.kds"
#include "kd/shaders/common/camera.kds"
#include "kd/shaders/common/lights.kds"
#include "kd/shaders/common/math.kds"
#include "kd/shaders/common/pbr.kds"
#include "kd/shaders/common/compute.kds"

#pragma compute CSMain

struct PushConstants
{
    uint Depth;
    uint Normal;
    uint Albedo;
    uint PBR;

    uint OutputDiffuse;
    uint OutputSpecular;
    uint Width;
    uint Height;

    uint PointLightArray;
    uint PointLightCount;
    uint CameraDataSRV;
    uint TileWidth;

    uint TileHeight;
    uint NumTilesX;
    uint BinsArray;
    uint TilesArray;

    uint SpotLightArray;
    uint SpotLightCount;
    uint SunArray;
    uint ShadowMask;
};
PUSH_CONSTANTS(PushConstants, Push);

// -----------------------------------------------------------------------------
// Split-light evaluation: returns pre-albedo diffuse *irradiance* (Ei)
// and specular *radiance* (Ls). Diffuse has NO albedo/kD/π here.
// -----------------------------------------------------------------------------
struct LightSplit { float3 Ei; float3 Ls; };

LightSplit EvalPointLightSplit(PointLight light, float3 V, float4 P, float3 N, float3 baseColor, float metallic, float roughness)
{
    float3 Lvec = light.Position - P.xyz;
    float  dist = length(Lvec);
    float3 L    = Lvec / max(dist, 1e-4);

    float  NdotL = max(dot(N, L), 0.0);
    float  NdotV = max(dot(N, V), 1e-4);
    float3 H     = normalize(V + L);
    float  HdotV = max(dot(H, V), 1e-4);

    // Distance/range attenuation
    float attenuation = 1.0 / (dist * dist + 1.0);
    attenuation *= saturate(1.0 - dist / light.Radius);

    // Incoming radiance from light
    float3 Li = attenuation * light.Color * light.Intensity;

    // Specular BRDF
    float  D  = DistributionGGX(N, H, roughness);
    float  G  = GeometrySmith(N, V, L, roughness);
    float3 F0 = lerp(float3(0.04, 0.04, 0.04), baseColor, metallic);
    float3 F  = FresnelSchlick(HdotV, F0);
    float3 f_spec = (D * G * F) / max(4.0 * NdotL * NdotV + 1e-4, 1e-4);

    LightSplit s;
    s.Ei = Li * NdotL;            // diffuse irradiance (pre-albedo, no /π)
    s.Ls = f_spec * Li * NdotL;   // specular radiance
    return s;
}

LightSplit EvalSpotLightSplit(SpotLight light, float3 V, float4 P, float3 N, float3 baseColor, float metallic, float roughness)
{
    LightSplit s = (LightSplit)0;
    float3 Lvec = light.Position - P.xyz;
    float  dist = length(Lvec);
    float3 L    = Lvec / max(dist, 1e-4);

    // Cone falloff
    float  spotFactor = dot(-L, normalize(light.Forward));
    float  cosA       = cos(light.Angle);
    float  falloff    = saturate((spotFactor - cosA) / (1.0 - cosA));
    if (falloff <= 1e-4) { return s; }

    // Distance/range attenuation
    float attenuation = 1.0 / (dist * dist + 1.0);
    attenuation *= saturate(1.0 - dist / light.Size);
    attenuation *= falloff;

    float  NdotL = max(dot(N, L), 0.0);
    float  NdotV = max(dot(N, V), 1e-4);
    float3 H     = normalize(V + L);
    float  HdotV = max(dot(H, V), 1e-4);

    float3 Li = attenuation * light.Color * light.Intensity;

    float  D  = DistributionGGX(N, H, roughness);
    float  G  = GeometrySmith(N, V, L, roughness);
    float3 F0 = lerp(float3(0.04, 0.04, 0.04), baseColor, metallic);
    float3 F  = FresnelSchlick(HdotV, F0);
    float3 f_spec = (D * G * F) / max(4.0 * NdotL * NdotV + 1e-4, 1e-4);

    s.Ei = Li * NdotL;
    s.Ls = f_spec * Li * NdotL;
    return s;
}

LightSplit EvalDirectionalLightSplit(DirectionalLight light, float3 V, float4 P, float3 N, float3 baseColor, float metallic, float roughness)
{
    float3 L = -light.Direction;

    float  NdotL = max(dot(N, L), 0.0);
    float  NdotV = max(dot(N, V), 1e-4);
    float3 H     = normalize(V + L);
    float  HdotV = max(dot(H, V), 1e-4);

    float3 Li = light.Color * light.Intensity; // no distance attenuation

    float  D  = DistributionGGX(N, H, roughness);
    float  G  = GeometrySmith(N, V, L, roughness);
    float3 F0 = lerp(float3(0.04, 0.04, 0.04), baseColor, metallic);
    float3 F  = FresnelSchlick(HdotV, F0);
    float3 f_spec = (D * G * F) / max(4.0 * NdotL * NdotV + 1e-4, 1e-4);

    LightSplit s;
    s.Ei = Li * NdotL;           // pre-albedo diffuse irradiance
    s.Ls = f_spec * Li * NdotL;  // specular radiance
    return s;
}

// -----------------------------------------------------------------------------

[numthreads(8, 8, 1)]
void CSMain(uint3 tid: SV_DispatchThreadID)
{
    if (tid.x >= Push.Width || tid.y >= Push.Height) return;

    // Resources
    Texture2D<float>     depth        = ResourceDescriptorHeap[Push.Depth];
    Texture2D<float4>    normal       = ResourceDescriptorHeap[Push.Normal];
    Texture2D<float4>    albedo       = ResourceDescriptorHeap[Push.Albedo];
    Texture2D<float2>    pbr          = ResourceDescriptorHeap[Push.PBR];
    Texture2D<float>     shadowMask   = ResourceDescriptorHeap[Push.ShadowMask];

    RWTexture2D<float4>  outDiffuse   = ResourceDescriptorHeap[Push.OutputDiffuse];  // RGB = Ei_dir
    RWTexture2D<float4>  outSpecular  = ResourceDescriptorHeap[Push.OutputSpecular]; // RGB = Ls_dir

    StructuredBuffer<PointLight>       pointLights = ResourceDescriptorHeap[Push.PointLightArray];
    StructuredBuffer<SpotLight>        spotLights  = ResourceDescriptorHeap[Push.SpotLightArray];
    StructuredBuffer<DirectionalLight> sun         = ResourceDescriptorHeap[Push.SunArray];
    StructuredBuffer<TileData>         tiles       = ResourceDescriptorHeap[Push.TilesArray];
    StructuredBuffer<uint>             bins        = ResourceDescriptorHeap[Push.BinsArray];
    ConstantBuffer<Camera>             camera      = ResourceDescriptorHeap[Push.CameraDataSRV];

    // Tile
    uint tileX = tid.x / Push.TileWidth;
    uint tileY = tid.y / Push.TileHeight;
    uint tileIndex = tileY * Push.NumTilesX + tileX;
    TileData tile = tiles[tileIndex];

    // G-buffer fetch
    float  viewDepth     = depth.Load(tid);
    float2 uv            = TexelToUV(tid.xy, float2(Push.Width, Push.Height));
    float3 cameraPos     = camera.Position.xyz;
    float4 worldPos      = GetWorldFromDepth(uv, viewDepth, camera.InvViewProj);
    float3 baseColor     = albedo.Load(tid).rgb;   // for F0 only (metals)
    float3 N             = normalize(normal.Load(tid).rgb);
    float  metallic      = pbr.Load(tid).r;
    float  roughness     = pbr.Load(tid).g;
    float3 V             = normalize(cameraPos - worldPos.xyz);

    // Accumulators
    float3 Ei_direct = 0.0.xxx;  // pre-albedo diffuse irradiance
    float3 Ls_direct = 0.0.xxx;  // specular radiance

    // Local lights
    [loop]
    for (int i = 0; i < tile.Count; i++) {
        uint encoded   = bins[tile.Offset + i];
        bool isSpot    = (encoded & (1u << 31)) != 0;
        uint idx       = encoded & 0x7FFFFFFF;

        LightSplit s;
        if (isSpot) s = EvalSpotLightSplit(spotLights[idx],  V, worldPos, N, baseColor, metallic, roughness);
        else s = EvalPointLightSplit(pointLights[idx], V, worldPos, N, baseColor, metallic, roughness);

        Ei_direct += s.Ei;
        Ls_direct += s.Ls;
    }

    // Sun (apply shadow to both components)
    {
        float sunShadow = shadowMask.Load(tid); // ∈ [0,1]
        LightSplit s = EvalDirectionalLightSplit(sun[0], V, worldPos, N, baseColor, metallic, roughness);
        Ei_direct += s.Ei * sunShadow;
        Ls_direct += s.Ls * sunShadow;
    }

    outDiffuse[tid.xy]  = float4(Ei_direct, 1.0);   // DirectDiffuseIrradiance
    outSpecular[tid.xy] = float4(Ls_direct, 1.0);   // DirectSpecularRadiance
}
