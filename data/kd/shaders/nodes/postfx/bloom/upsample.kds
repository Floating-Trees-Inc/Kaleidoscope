//
// > Notice: Floating Trees Inc. @ 2025
// > Create Time: 2025-08-20 14:16:00
//

#include "kd/shaders/common/bindless.kds"
#include "kd/shaders/common/compute.kds"
#include "kd/shaders/common/color.kds"

#pragma compute CSMain

struct PushConstants {
    float Gain;     // use as gain here (or split gain separately)
    uint  LinearSampler;
    uint  MipN;             // SRV: mip i (smaller)
    uint  MipNMinusOne;     // UAV: mip i-1 (larger)
};
PUSH_CONSTANTS(PushConstants, Push);

[numthreads(8, 8, 1)]
void CSMain(uint3 tid : SV_DispatchThreadID)
{
    Texture2D<float4>   src = ResourceDescriptorHeap[Push.MipN];          // mip i (half res)
    SamplerState        samp = SamplerDescriptorHeap[Push.LinearSampler];
    RWTexture2D<float4> dst  = ResourceDescriptorHeap[Push.MipNMinusOne]; // mip i-1 (fuller res)

    uint dstW, dstH; dst.GetDimensions(dstW, dstH);
    if (tid.x >= dstW || tid.y >= dstH) return;

    // IMPORTANT: no 0.5 scale here. UVs are normalized per mip.
    float2 uv = (float2(tid.xy) + 0.5) / float2(dstW, dstH);

    // force LOD 0 of the bound SRV mip (i), tent filter in texel offsets of mip i
    float3 a = src.SampleLevel(samp, uv, 0, int2(-1,  1)).rgb;
    float3 b = src.SampleLevel(samp, uv, 0, int2( 0,  1)).rgb;
    float3 c = src.SampleLevel(samp, uv, 0, int2( 1,  1)).rgb;
    float3 d = src.SampleLevel(samp, uv, 0, int2(-1,  0)).rgb;
    float3 e = src.SampleLevel(samp, uv, 0, int2( 0,  0)).rgb;
    float3 f = src.SampleLevel(samp, uv, 0, int2( 1,  0)).rgb;
    float3 g = src.SampleLevel(samp, uv, 0, int2(-1, -1)).rgb;
    float3 h = src.SampleLevel(samp, uv, 0, int2( 0, -1)).rgb;
    float3 i = src.SampleLevel(samp, uv, 0, int2( 1, -1)).rgb;

    float3 up = (e * 4.0 + (b + d + f + h) * 2.0 + (a + c + g + i)) * (1.0 / 16.0);

    float  gain = max(Push.Gain, 0.0);
    float3 base = dst[tid.xy].rgb;                     // accumulate
    dst[tid.xy] = float4(base + up * gain, 1.0);
}
