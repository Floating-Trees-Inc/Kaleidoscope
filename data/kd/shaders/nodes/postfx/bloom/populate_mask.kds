//
// > Notice: Floating Trees Inc. @ 2025
// > Create Time: 2025-08-20 14:16:00
//

#include "kd/shaders/common/bindless.kds"
#include "kd/shaders/common/compute.kds"
#include "kd/shaders/common/colors.kds"

#pragma compute CSMain

struct PushConstants
{
    uint EmissiveInput;
    uint LightingInput;
    uint MaskOutput;
    float Threshold;

    uint Width;
    uint Height;
    float ThresholdKnee;
    uint OnlyEmissive;
};
PUSH_CONSTANTS(PushConstants, Push);

// Soft threshold function with knee
float3 ThresholdFilter(float3 color)
{
    float brightness = Luminance(color);

    // Soft knee calculation
    float soft = brightness - Push.Threshold;
    soft = clamp(soft, 0, Push.ThresholdKnee);
    soft = soft * soft / (Push.ThresholdKnee * 2.0);

    // Combine hard and soft thresholds
    float contribution = max(soft, brightness - Push.Threshold);
    contribution /= max(brightness, 0.00001); // Prevent divide by zero

    return color * saturate(contribution);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 dtid : SV_DispatchThreadID)
{
    if (dtid.x >= Push.Width || dtid.y >= Push.Height)
        return;

    Texture2D<float4> lighting = ResourceDescriptorHeap[Push.LightingInput];
    Texture2D<float4> emissive = ResourceDescriptorHeap[Push.EmissiveInput];
    RWTexture2D<float4> outMask = ResourceDescriptorHeap[Push.MaskOutput];

    float4 lightColor = lighting.Load(dtid);
    float4 emissiveColor = emissive.Load(dtid);

    // Apply threshold only to lighting, add emissive directly
    float3 result = emissiveColor.rgb;
    if (Push.OnlyEmissive == 0)
        result += ThresholdFilter(lightColor.rgb);

    outMask[dtid.xy] = float4(result, 1.0);
}
